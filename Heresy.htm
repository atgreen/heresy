<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=File-List href="Heresy_files/filelist.xml">
<link rel=Edit-Time-Data href="Heresy_files/editdata.mso">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Heresy</title>
<!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:Zoom>BestFit</w:Zoom>
  <w:SpellingState>Clean</w:SpellingState>
  <w:GrammarState>Clean</w:GrammarState>
  <w:PunctuationKerning/>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:Compatibility>
   <w:BreakWrappedTables/>
   <w:SnapToGridInCell/>
   <w:WrapTextWithPunct/>
   <w:UseAsianBreakRules/>
   <w:DontGrowAutofit/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h1
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:16.0pt;
	font-family:Arial;
	mso-font-kerning:16.0pt;
	font-weight:bold;}
h2
	{mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	mso-outline-level:2;
	font-size:18.0pt;
	font-family:"Times New Roman";
	font-weight:bold;}
h3
	{mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	mso-outline-level:3;
	font-size:13.5pt;
	font-family:"Times New Roman";
	font-weight:bold;
	text-decoration:underline;
	text-underline:single;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 3.0in right 6.0in;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 3.0in right 6.0in;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
a:link, span.MsoHyperlink
	{color:blue;
	mso-text-animation:none;
	text-decoration:none;
	text-underline:none;
	text-decoration:none;
	text-line-through:none;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;
	text-underline:single;}
p
	{mso-style-link:"Normal \(Web\) Char";
	mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
tt
	{font-family:"Courier New";
	mso-ascii-font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:"Courier New";}
span.NormalWebChar
	{mso-style-name:"Normal \(Web\) Char";
	mso-style-locked:yes;
	mso-style-link:"Normal \(Web\)";
	mso-ansi-font-size:12.0pt;
	mso-bidi-font-size:12.0pt;
	mso-ansi-language:EN-US;
	mso-fareast-language:EN-US;
	mso-bidi-language:AR-SA;}
span.SpellE
	{mso-style-name:"";
	mso-spl-e:yes;}
span.GramE
	{mso-style-name:"";
	mso-gram-e:yes;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Table Normal";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0in 5.4pt 0in 5.4pt;
	mso-para-margin:0in;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
table.MsoTableGrid
	{mso-style-name:"Table Grid";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	border:solid windowtext 1.0pt;
	mso-border-alt:solid windowtext .5pt;
	mso-padding-alt:0in 5.4pt 0in 5.4pt;
	mso-border-insideh:.5pt solid windowtext;
	mso-border-insidev:.5pt solid windowtext;
	mso-para-margin:0in;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:DocumentProperties>   </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext="edit" spidmax="15362">
  <o:colormenu v:ext="edit" fillcolor="silver"/>
 </o:shapedefaults></xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=EN-US link=blue vlink=purple style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoNormal><a href="http://sourceforge.net"><img border=0 width=88
height=31 id="_x0000_i1025"
src="http://sflogo.sourceforge.net/sflogo.php?group_id=204995&amp;type=1"
alt="SourceForge.net Logo"></a></p>

<h2><span class=GramE>HERESY – <span class=SpellE>Haskellesque</span> lazy-list
and functional tools with a Common Lisp slant.</span></h2>

<p class=MsoNormal><br>
&nbsp;</p>

<h3><a name=abstract>Abstract</a></h3>

<p class=MsoNormal>Heresy is a list of utilities for lazy and functional
programming in Common Lisp.<span style='mso-spacerun:yes'>  </span>Function
names are chosen and decorated so as to resemble Haskell and/or CL equivalents;
but to allow full import of exported symbols into a typical namespace.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The lazy-list functions provided are for when the memory/<span
class=SpellE>cpu</span> profile of lazy list evaluation, or list-based
solutions requiring lazy evaluation (such as self-referencing lists, or
sequences with issues running beyond some termination point) are desired.<span
style='mso-spacerun:yes'>  </span>Expressive interoperation/conversion between
CL sequences and lazy-lists, and control over degree of “laziness” are design
goals.<span style='mso-spacerun:yes'>  </span>Lists can be heterogeneous
(containing elements of different types), and functions named after Haskell
list equivalents may be altered for <span class=SpellE>lispiness</span>.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The code comes with a <a
href="http://www.opensource.org/licenses/bsd-license.php">BSD-style license</a>
so you can basically do with it whatever you want. </p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Heresy library source can be downloaded at <a
href="http://sourceforge.net/projects/cl-heresy/">http://sourceforge.net/projects/cl-heresy/</a></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Heresy is listed at <a
href="http://www.cl-user.net/asp/libs/Heresy">http://www.cl-user.net/asp/libs/Heresy</a></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>I’ll attempt to obtain a mailing list as soon as possible.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<h3>Highlights/Examples</h3>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>Naming
conventions:<o:p></o:p></i></p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'>Generally, function names and call
signatures are chosen to replicate a Haskell, CL or both - generally with a
trailing <span class=GramE>/ .</span></p>

<p class=MsoNormal style='margin-left:1.0in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'><span class=NormalWebChar>(<span
class=GramE>list</span>/ 3 2 1 0) </span><span
style='mso-spacerun:yes'>                                 </span><span
style='mso-tab-count:2'>                   </span>; returns lazy-list (3 2 1 0)</p>

<p class=MsoNormal style='margin-left:1.0in'>(<span class=GramE>map</span>/ #'+
(list/ 1 2 3) (list/ 4 5 6))<span style='mso-spacerun:yes'>  </span><span
style='mso-tab-count:2'>                   </span>; returns lazy-list (5 7 9)</p>

<p class=MsoNormal style='margin-left:1.0in'>(<span class=GramE>nub-</span>by/
‘equal (list/ 1 4 2 3 2 1))<span style='mso-spacerun:yes'>  </span><span
style='mso-tab-count:2'>                   </span>; loose equivalent of <span
class=SpellE>haskell’s</span> <span class=SpellE>nubBy</span></p>

<p class=MsoNormal style='margin-left:1.0in'>(<span class=GramE>tail</span>/
(list/ 1 2 3 4)) or (<span class=SpellE>cdr</span>/ (list/ 1 2 3 4))<span
style='mso-spacerun:yes'>     </span><span style='mso-tab-count:1'>     </span>;
returns tail of the list</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>Interoperability:<o:p></o:p></i></p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'>Lazy-list functions accept
lazy-lists as well as CL strings, lists and arrays (leveraging optimizations
where possible).<span style='mso-spacerun:yes'>  </span>Multi-dimension arrays
are turned into lazy-lists of lazy-lists.</p>

<p class=MsoNormal style='margin-left:1.0in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'>(<span class=GramE>map</span>/
#'list &quot;Hello&quot; (list 1 2 3) #(4 5 6) (list/ “X” “Y” “Z”))<span
style='mso-spacerun:yes'>     </span>; returns lazy-list ((#\H 1 4
&quot;X&quot;) (#\e 2 5 &quot;Y&quot;) (#\l 3 6 &quot;Z&quot;) )</p>

<p class=MsoNormal style='margin-left:1.0in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'><span class=GramE>to-array</span>,
to-string, to-list evaluate lazy-list (run to its end) into their respective CL
types.</p>

<p class=MsoNormal style='margin-left:1.0in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'>(<span class=GramE><b
style='mso-bidi-font-weight:normal'><span style='color:black'>to-array</span></b></span>
(map/ #'+ (list/ 1 2 3) (list/ 4 5 6)))<span style='mso-spacerun:yes'>   
</span>; returns array #(5 7 9)</p>

<p class=MsoNormal style='margin-left:1.0in'>(<span class=GramE><b
style='mso-bidi-font-weight:normal'>to-list</b></span><b style='mso-bidi-font-weight:
normal'> </b>(map/ #'+ (list/ 1 2 3) (list/ 4 5 6)))<span
style='mso-spacerun:yes'>        </span>; returns CL proper list (5 7 9)</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>Self-referencing
lists:<o:p></o:p></i></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'>The clichéd Fibonacci example:</p>

<p class=MsoNormal style='margin-left:1.0in'>(Request 1000000<sup>th</sup>
element in Fibonacci sequence using self-referencing list)</p>

<p class=MsoNormal style='margin-left:1.0in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'>(<span class=GramE>nth</span>/
1000000</p>

<p class=MsoNormal style='margin-left:1.0in'><span
style='mso-spacerun:yes'> </span>(<b style='mso-bidi-font-weight:normal'><span
style='color:green'>self-ref-list/</span></b> <b style='mso-bidi-font-weight:
normal'><span style='color:blue'>fib</span></b> (list*/ 1 <span class=SpellE>1</span>
(map/ #'+ <b style='mso-bidi-font-weight:normal'><span style='color:blue'>fib</span></b>
(tail/ <b style='mso-bidi-font-weight:normal'><span style='color:blue'>fib</span></b>)))))</p>

<p class=MsoNormal style='margin-left:1.0in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'>; <span class=GramE>self-ref-list</span>
internally <span class=SpellE>memoized</span> (to allow order-n solution); but
with deferred creation (until extract time) to prevent storage bloat by holders
of list reference.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>Control
over laziness:<o:p></o:p></i></p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'><span
style='mso-spacerun:yes'> </span>(<span class=SpellE><span class=GramE>defparameter</span></span>
my-list '(1 2 3 4 5))</p>

<p class=MsoNormal style='margin-left:1.0in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'><span
style='mso-spacerun:yes'> </span>(<span class=GramE><b style='mso-bidi-font-weight:
normal'><span style='color:green'>eager</span></b></span> (<span
style='color:blue'>tail/</span> (<span style='color:blue'>tail/</span>
my-list))) ; returns lazy-list that internally points to subset of my-list list
'(3 4)</p>

<p class=MsoNormal style='margin-left:1.0in'><span
style='mso-spacerun:yes'> </span>(<span class=GramE><b style='mso-bidi-font-weight:
normal'><span style='color:green'>lazy</span></b></span> (<span
style='color:blue'>tail/</span> (<span style='color:blue'>tail/</span>
my-list)))<span style='mso-spacerun:yes'>   </span>; returns lazy-list that has
traversal through 2 elements deferred (until first request) – closure
internally references my-list '(1 2 3 4)</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>Convenient,
functional lazy parsing/decomposition of data structures:<o:p></o:p></i></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'>This example “picks apart” the
contents of a CSV (comma separated value) file, which <i style='mso-bidi-font-style:
normal'>can</i> be a lazy-list of chars.<span style='mso-spacerun:yes'> 
</span>It handles the case of commas in strings, and doesn’t use them as the
basis of a list.<span style='mso-spacerun:yes'>  </span>The result is a lazy-list
of lazy-lists representing the comma-separated sections.</p>

<p class=MsoNormal style='margin-left:1.0in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'>(The algorithm basically converts
each line’s chars into (cons char is-quote), then <span class=SpellE>scanl</span>/’s
these to mark each char as “in quotes”, to use as a basis for split only on
commas that are not in quotes, i.e. ‘(#\<span class=GramE>, .</span> NIL<span
class=GramE>)<span style='mso-spacerun:yes'>  </span>)</span></p>

<p class=MsoNormal style='margin-left:1.0in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><b style='mso-bidi-font-weight:
normal'><span style='font-size:10.0pt'>REPL&gt;</span></b></tt><tt><span
style='font-size:10.0pt'> (<span class=SpellE>defparameter</span> <span
class=SpellE><b style='mso-bidi-font-weight:normal'>csv</b></span><b
style='mso-bidi-font-weight:normal'>-file</b><o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><span
style='mso-spacerun:yes'>      </span>&quot;1<span class=GramE>,2</span>, 3 , I
contain \&quot; Quoted, commas, \&quot; you see, 99<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><span
style='mso-spacerun:yes'>      </span><span class=GramE>g</span>, \&quot;<span
class=SpellE>hijk\&quot;lmn</span><o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><span
style='mso-spacerun:yes'>      </span><span class=SpellE>third_line<span
class=GramE>,stuff</span></span> here&quot;)<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><b style='mso-bidi-font-weight:
normal'><span style='font-size:10.0pt'>REPL&gt;</span></b></tt><tt><span
style='font-size:10.0pt'> (map/ (curried #'map/ (composed #'to-string (curried
#'map/ #'car)))<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><span
style='mso-spacerun:yes'>      </span><span
style='mso-spacerun:yes'>    </span>(<span class=GramE>map</span>/ (composed<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><span
style='mso-spacerun:yes'>                 </span>(<span class=GramE>lambda</span>
(line) (split-down-on-test/ (curried <b style='mso-bidi-font-weight:normal'>#'equal
'(#\, . nil)</b>) line))<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><span
style='mso-spacerun:yes'>                 </span>(<span class=GramE>curried</span>
#'scanl1/ (lambda (a b) (cons (car b) (if (<span class=SpellE>cdr</span> a)
(not (<span class=SpellE>cdr</span> b)) (<span class=SpellE>cdr</span> b)))))<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><span
style='mso-spacerun:yes'>                 </span>(<span class=GramE>curried</span>
#'map/ (lambda (<span class=SpellE>elt</span>) (cons <span class=SpellE>elt</span>
<b style='mso-bidi-font-weight:normal'>(<span class=SpellE>eql</span> <span
class=SpellE>elt</span> #\&quot;)))))</b><o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><span
style='mso-spacerun:yes'>                </span>(split-down-on-test/ (curried
#'<span class=SpellE>eql</span> #\newline) <span class=SpellE><b
style='mso-bidi-font-weight:normal'>csv</b></span><b style='mso-bidi-font-weight:
normal'>-file</b>)))<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'>Returns the result:</p>

<p class=MsoNormal style='margin-left:1.0in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'>(LIST/</p>

<p class=MsoNormal style='margin-left:1.0in;text-indent:.5in'><span
style='mso-spacerun:yes'> </span>(LIST/ &quot;1&quot; &quot;2&quot; <span
class=GramE>&quot; 3</span> &quot; &quot; I contain \&quot; Quoted, commas,
\&quot; you see&quot; &quot; 99&quot;)</p>

<p class=MsoNormal style='margin-left:1.0in;text-indent:.5in'><span
style='mso-spacerun:yes'> </span>(LIST/ &quot;g&quot; <span class=GramE>&quot;
\</span>&quot;<span class=SpellE>hijk\&quot;lmn</span>&quot;)</p>

<p class=MsoNormal style='margin-left:1.0in;text-indent:.5in'><span
style='mso-spacerun:yes'> </span>(LIST/ &quot;<span class=SpellE>third_line</span>&quot;
&quot;stuff here&quot;))</p>

<p class=MsoNormal style='margin-left:1.0in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<h3>Installation:</h3>

<p class=MsoNormal style='margin-left:.5in'>Install from <a
href="http://www.sourceforge.net/">www.sourceforge.net</a></p>

<p class=MsoNormal style='margin-left:.5in'>Heresy is <span class=SpellE>asdf</span>-compliant.</p>

<p class=MsoNormal style='margin-left:.5in'>(<span class=GramE>use-package</span>
:heresy) is recommended as the functions are intended to be used frequently, and
the symbols were chosen so as to not clash with known libraries.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<h3>Performance:</h3>

<p class=MsoNormal style='margin-left:.5in'>Heresy’s lazy-list operations are
generally functions that accept values and functions – in a straight-up example,
map/ (plus expansion of its emitted list) cannot match the CPU performance of a
straight-up <span class=SpellE>mapcar</span>/.<span style='mso-spacerun:yes'> 
</span>Loop/while can generally outrun the expanded map/ and filter/
equivalent.<span style='mso-spacerun:yes'>  </span>In typical use, any given
expression may be composed of both lazy-list and CL functions.</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'>What lazy-list use can do is alter
the memory profile of a solution, or relocate the performance hit of expensive
list traversals to the user rather than the definer.</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'>The memory advantages may be
realized through creation of lazy-lists that “contain” large objects – this
list may be declared in terms of functional constructs without the static
memory requirement of keeping them all in RAM.<span style='mso-spacerun:yes'> 
</span>If the end-user of this list filters them, or uses them in a loop, or
uses/discards them as the basis for a subsequent computation, the system may
only have one in RAM (and uncollectable) at a time.</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'>(<span class=SpellE><span
class=GramE>defun</span></span> make-lazy-list-of-huge-results (inputs)</p>

<p class=MsoNormal style='margin-left:1.0in'><span style='mso-spacerun:yes'> 
</span>(<span class=GramE>map</span>/ #'make-huge-result inputs))</p>

<p class=MsoNormal style='margin-left:1.0in'>; returns lazy-list of
huge-results</p>

<p class=MsoNormal style='margin-left:1.0in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'>(<span class=GramE>let</span> ((<b
style='mso-bidi-font-weight:normal'>huge-results</b> (make-lazy-list-of-huge-results
inputs)))<span style='mso-spacerun:yes'>  </span>; minimal memory footprint, no
huge results actually created yet.</p>

<p class=MsoNormal style='margin-left:1.0in'><span style='mso-spacerun:yes'> 
</span>(<span class=GramE>map</span>/ #'make-small-result <b style='mso-bidi-font-weight:
normal'>huge-results</b>))<span style='mso-spacerun:yes'>   </span>; <span
class=GramE>huge-results</span> created and discarded one at a time.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<h3>Thread-Safety:</h3>

<p class=MsoNormal style='margin-left:.5in'>Thread-safety is designed in; but
presently deactivated.<span style='mso-spacerun:yes'>  </span>It will generally
entail function call contexts similar to <i style='mso-bidi-font-style:normal'>Eager</i>
and <i style='mso-bidi-font-style:normal'>Lazy</i> ; but come with a
significant performance cost wherever used (first-time traversal of certain <span
class=SpellE>memoized</span> sequences, or operations that work internally in terms
of them, will pay a locking <span class=SpellE>pentalty</span>).</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'>Thread-safety will be reactivated
in a future release, along with a dependency upon <a
href="http://common-lisp.net/project/bordeaux-threads/">Bordeaux-threads</a>.</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'>In heresy’s current non-thread-safe
guise, it is advisable to have any lazy-list or fragment thereof only available
for read, evaluation or traversal by one thread at a time.<span
style='mso-spacerun:yes'>  </span>To be extra-safe, consider only transferring
frozen containers (proper lists, arrays) between threads.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<h3>Functions:</h3>

<p class=MsoNormal style='margin-left:.5in'>Note:<span
style='mso-spacerun:yes'>  </span>Unless otherwise specified, functions
accepting lists as parameters will accept <i style='mso-bidi-font-style:normal'>any</i>
lazy-list, proper list, or other CL sequence, any of which can be
heterogeneous.<span style='mso-spacerun:yes'>  </span>In this regard, strings
are considered lists of type character.<span style='mso-spacerun:yes'> 
</span>Lazy-lists that are direct wrappers for strings, vectors or arrays will
maintain a reference to the entire array, even if they represent only a subset
of the array’s values.<span style='mso-spacerun:yes'>  </span>(Where retention
of the original container is undesirable, they, or a derived result <span
class=SpellE>result</span>, should be evaluated into a new non-lazy container).</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'>Unless otherwise specified,
functions return lazy-lists (although where possible, these are internally
indicated as being based on a static container for optimizations in other
functions).</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'>Where possible, functions accepting
lists switch on/are optimized for lists or sequences, or for lazy-lists that
happen to be wrapping lazy-lists.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<h3><span style='font-size:12.0pt'>Interoperability:<o:p></o:p></span></h3>

<p><o:p>&nbsp;</o:p></p>

<p>[Function<span class=GramE>]</span><br>
<a name="string-from-chars/"><b>string-from-chars/</b> <i>chars-list</i> =&gt; <i>result</i></a>
</p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>Equivalent
to to-string<o:p></o:p></i></p>

<p class=MsoNormal style='margin-left:.5in'><span class=GramE>Evaluates the
provided char-list (which can be a lazy-list or CL sequence) to its end,
concatenating all chars into a single string.</span><span
style='mso-spacerun:yes'>  </span>Call will fail if any elements in its input
list are non-characters.</p>

<p><span style='mso-spacerun:yes'> </span>[Function<span class=GramE>]</span><br>
<a name=to-list><b>to-list</b> <i>list</i> =&gt; </a><i>CL proper list</i> </p>

<p class=MsoNormal style='margin-left:.5in'><span class=GramE>Returns the input
list in proper-list form – evaluating all values to the end.</span></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p>[Function<span class=GramE>]</span><br>
<b>to-array</b> <i>list </i><tt><i><span style='font-size:10.0pt'>&amp;rest</span></i></tt><i>
array-<span class=SpellE>params</span></i> =&gt; <i>CL Array</i> </p>

<p class=MsoNormal style='margin-left:.5in'><span class=GramE>Returns the input
list in array form – evaluating all values to the end.</span><span
style='mso-spacerun:yes'>  </span>Any (optional) <i style='mso-bidi-font-style:
normal'>array-<span class=SpellE>params</span></i> provided are fed to an
internal call to common-<span class=SpellE>lisp:<span class=GramE>:make</span></span>-array
– see the CL spec for documentation on its &amp;key parameters.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p>[Generic function<span class=GramE>]</span><br>
<b>to-string</b> <i>chars-list</i> =&gt; <i>string</i></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>Equivalent
to <span class=SpellE>sstring</span>-from-chars/<o:p></o:p></i></p>

<p class=MsoNormal style='margin-left:.5in'><span class=GramE>Evaluates the
provided char-list (which can be a lazy-list or CL sequence) to its end,
concatenating all chars into a single string.</span><span
style='mso-spacerun:yes'>  </span>Call will fail if any elements in its input
list are non-characters.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<h3><span style='font-size:12.0pt'>Meat and Potatoes:<o:p></o:p></span></h3>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p>[Function<span class=GramE>]</span><br>
<a name="and/"><b>and/</b> <i>list</i> =&gt; </a><i>last element in list or NIL</i>
</p>

<p class=MsoNormal style='margin-left:.5in'>Returns nil if any element in the
provided <i style='mso-bidi-font-style:normal'>list</i> is nil, otherwise
returns the last element </p>

<p><br>
<!-- End of entry for AND/ --><!-- Entry for APPEND/ -->[Function<span
class=GramE>]</span><br>
<b>append/</b> <a name="append/"><tt><i><span style='font-size:10.0pt'>&amp;rest</span></i></tt><i>
lists</i> =&gt; </a><i>lazy-list of inputs chained consecutively</i> </p>

<p class=MsoNormal style='margin-left:.5in'>Lazy equivalent of CL’s <i
style='mso-bidi-font-style:normal'>append</i> – returns a lazy-list of its
input lists (which can be CL sequences or lazy-lists) chained end to end.<span
style='mso-spacerun:yes'>  </span>Internally implemented in terms of <span
class=SpellE><i style='mso-bidi-font-style:normal'>concat</i></span><i
style='mso-bidi-font-style:normal'>/</i></p>

<p><br>
<!-- End of entry for APPEND/ --><!-- Entry for ASSOC/ -->[Function<span
class=GramE>]</span><br>
<b>assoc/</b> <i>item <span class=SpellE>alist</span> </i><tt><i><span
style='font-size:10.0pt'>&amp;rest</span></i></tt><i> assoc-rest-<span
class=SpellE>params</span></i><a name="assoc/"> =&gt; </a><i>found result or
NIL</i></p>

<p class=MsoNormal style='margin-left:.5in'>Equivalent of CL’s <i
style='mso-bidi-font-style:normal'>assoc</i> – accepts a lazy-list of
cons-cells, returns a found result or nil.<span style='mso-spacerun:yes'> 
</span><span class=GramE>The &amp;</span>key <span class=SpellE>params</span>
in <i>assoc-rest-<span class=SpellE>params</span></i> work as equivalents to
those in CL’s <i style='mso-bidi-font-style:normal'>assoc</i>.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p>[Function<span class=GramE>]</span><br>
<b>car/, <span class=SpellE>cdr</span>/, <span class=SpellE>cadr</span>/,
c****r/</b> <tt><i><span style='font-size:10.0pt'>&amp;list</span></i></tt><i> </i>=&gt;
<i>Result</i></p>

<p class=MsoNormal style='margin-left:.5in'>Lazy-list substitutes for CL’s car,
<span class=SpellE>cdr</span>, <span class=SpellE>cadr</span>, etc.<span
style='mso-spacerun:yes'>  </span><span class=GramE>Implemented up to 5
composing characters.</span></p>

<p class=MsoNormal style='margin-left:.5in'>Any <i style='mso-bidi-font-style:
normal'>car </i>components result in instant traversal to obtain the first
value in a lazy-list.</p>

<p class=MsoNormal style='margin-left:.5in'>Any <span class=SpellE><span
class=GramE><i style='mso-bidi-font-style:normal'>cdr</i></span></span>
components to the function called request traversal based on the current
“laziness’ context.</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>In
Eager context:</i> <span class=SpellE><span class=GramE><i style='mso-bidi-font-style:
normal'>cdr</i></span></span> components traverse immediately, returning the
new head of the list.</p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>In
Lazy context: <span class=SpellE><span class=GramE>cdr</span></span></i> components
return the original list + deferred traversal – true traversal only occurs on
first traversal of the result.<span style='mso-spacerun:yes'> 
</span>Performance Warning:<span style='mso-spacerun:yes'>  </span>In a <i
style='mso-bidi-font-style:normal'>Lazy</i> context, <span class=SpellE><i
style='mso-bidi-font-style:normal'>cdr</i></span><i style='mso-bidi-font-style:
normal'>/</i> (or composed equivalent) of a lazy-list stores the original list
+ the <span class=SpellE>traverser</span>, so lazy <span class=SpellE><i
style='mso-bidi-font-style:normal'>cdr</i></span><i style='mso-bidi-font-style:
normal'>/</i> of a list that’s holding a certain amount of RAM won’t alter the
required RAM.</p>

<p><br>
[Function<span class=GramE>]</span><br>
<a name=composed><b>composed</b> </a><span style='mso-bookmark:composed'><tt><i><span
style='font-size:10.0pt'>&amp;rest</span></i></tt><i> functions</i> =&gt; </span><i>composition
of functions</i> </p>

<p class=MsoNormal style='margin-left:.5in'>Composes functions provided as
parameters.</p>

<p class=MsoNormal style='margin-left:.5in'>(<span class=GramE>composed</span>
#'<span class=SpellE>aa</span> #'bb) returns a function that calls #'bb on its <span
class=SpellE>params</span>, then passes the result to a call to #'<span
class=SpellE>aa</span></p>

<p><br>
<!-- End of entry for COMPOSED --><!-- Entry for CONCAT/ -->[Function<span
class=GramE>]</span><br>
<span class=SpellE><b>concat</b></span><a name="concat/"><b>/</b> <i>list-of-lists</i>
=&gt; </a><i>lazy-list of inputs chained consecutively</i></p>

<p class=MsoNormal style='margin-left:.5in'>Returns the provided list-of-lists
concatenated consecutively, as a lazy-list.<span style='mso-spacerun:yes'> 
</span>Uses various internal optimizations based upon their input types.<span
style='mso-spacerun:yes'>  </span>Input parameter <i style='mso-bidi-font-style:
normal'>list-of-lists</i> is only traversed as the result traversal reaches the
end of each sub-list’s values.</p>

<p><br>
<!-- End of entry for CONCAT/ --><!-- Entry for CURRIED -->[Function<span
class=GramE>]</span><br>
<a name=curried><b>curried</b> <i>function </i></a><span style='mso-bookmark:
curried'><tt><i><span style='font-size:10.0pt'>&amp;rest</span></i></tt><i> <span
class=SpellE>largs</span></i> =&gt; </span><i>function</i></p>

<p class=MsoNormal style='margin-left:.5in'>Returns a function that applies <span
class=SpellE><i style='mso-bidi-font-style:normal'>largs</i></span> + its
parameters to <i style='mso-bidi-font-style:normal'>function</i></p>

<p><br>
<!-- End of entry for CURRIED --><!-- Entry for DROP-WHILE/ -->[Function<span
class=GramE>]</span><br>
<a name="drop-while/"><b>drop-while/</b> <i>test list</i> =&gt; </a><i>lazy-list</i></p>

<p class=MsoNormal style='margin-left:.5in'>Returns a list that has elements
dropped from <i style='mso-bidi-font-style:normal'>list</i> while function <i
style='mso-bidi-font-style:normal'>test</i> applied to the list element is
non-NIL, or end is reached.</p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>In
Eager context: </i>Traverses list immediately, returning only from first where <i
style='mso-bidi-font-style:normal'>test</i> returns NIL.</p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>In
Lazy context:</i> Does not traverse <i style='mso-bidi-font-style:normal'>list</i>
on call – first traversal of result will trigger test to find first
non-NIL.<span style='mso-spacerun:yes'>  </span>(Storage warning:<span
style='mso-spacerun:yes'>  </span>result will keep references to original list
+ the test function).</p>

<p><br>
<!-- End of entry for DROP-WHILE/ --><!-- Entry for DROP/ -->[Function<span
class=GramE>]</span><br>
<a name="drop/"><b>drop/</b> <i>to-drop list</i> =&gt; </a><i>lazy-list</i></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>Identical
to <span class=SpellE>nthcdr</span>/<o:p></o:p></i></p>

<p class=MsoNormal style='margin-left:.5in'>Returns lazy-list with first <i
style='mso-bidi-font-style:normal'>to-drop</i> elements skipped/traversed from
list, or empty list if end reached<span class=GramE>..</span></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>In
Eager context: </i>Traverses list immediately, returning sub-list after <i
style='mso-bidi-font-style:normal'>drop-list</i> traversals<span class=GramE>..</span></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>In
Lazy context:</i> Does not traverse <i style='mso-bidi-font-style:normal'>list</i>
on call – first traversal of result will trigger traversal of <i
style='mso-bidi-font-style:normal'>list</i> until <i style='mso-bidi-font-style:
normal'>to-drop</i> elements are skipped or end is <span class=GramE>found.</span><span
style='mso-spacerun:yes'>  </span>(Storage warning:<span
style='mso-spacerun:yes'>  </span>result will internally keep references to
original list + to-drop).</p>

<p><br>
<!-- End of entry for DROP/ --><!-- Entry for EAGER -->[Macro<span class=GramE>]</span><br>
<a name=eager><b>eager</b> <i>declaration* statement*</i> =&gt; <i>result</i></a>
</p>

<p style='margin-left:.5in'>Enters an &quot;Eager&quot; context - calls to
functions such as tail/ do traversal before returning. This context uses a
special variable, and extends into sub-calls until overridden.<span
style='mso-spacerun:yes'>  </span>Eager context is the default.<span
style='mso-spacerun:yes'>  </span>Relevant functions are documented with their
respective context effects.</p>

<p><br>
<!-- End of entry for EAGER --><!-- Entry for FILTER/ -->[Function<span
class=GramE>]</span><br>
<a name="filter/"><b>filter/</b> <i>predicate list</i> =&gt; </a><i>lazy-list</i></p>

<p class=MsoNormal style='margin-left:.5in'>Traversal of the resultant list
skips any <i style='mso-bidi-font-style:normal'>list</i> elements for which
running <i style='mso-bidi-font-style:normal'>predicate</i> against the element
fails.</p>

<p class=MsoNormal style='margin-left:.5in'>(Storage warning:<span
style='mso-spacerun:yes'>  </span>resultant list will internally keep references
to original list + predicate).</p>

<p><br>
<!-- End of entry for FILTER/ --><!-- Entry for FIRST/ -->[Function<span
class=GramE>]</span><br>
<a name="first/"><b>first/</b> <i>list</i> =&gt; </a><i>value</i></p>

<p class=MsoNormal style='margin-left:.5in'><span class=GramE>Lazy-list
equivalent of CL’s <i style='mso-bidi-font-style:normal'>first</i> function.</span><span
style='mso-spacerun:yes'>  </span><span class=GramE>Returns first element in a
list, or NIL if nothing present.</span></p>

<p><br>
<!-- End of entry for FIRST/ --><!-- Entry for FOLDL/ -->[Function<span
class=GramE>]</span><br>
<span class=SpellE><b>foldl</b></span><a name="foldl/"><b>/</b> <i>function
first list</i> =&gt; <i>result</i></a> </p>

<p class=MsoNormal style='margin-left:.5in'>Equivalent of Haskell’s <span
class=SpellE>foldl</span> – better explained on the net.</p>

<p><br>
<!-- End of entry for FOLDL/ --><!-- Entry for FOLDL1/ -->[Function<span
class=GramE>]</span><br>
<a name="foldl1/"><b>foldl1/</b> <i>function list</i> =&gt; <i>result</i></a> </p>

<p class=MsoNormal style='margin-left:.5in'>Equivalent of Haskell’s foldl1 – <span
class=SpellE>foldl</span> with the first in the list used as <i
style='mso-bidi-font-style:normal'>first</i></p>

<p><br>
<!-- End of entry for FOLDL1/ --><!-- Entry for FOLDR/ -->[Function<span
class=GramE>]</span><br>
<span class=SpellE><b>foldr</b></span><a name="foldr/"><b>/</b> <i>function
first list</i> =&gt; <i>result</i></a> </p>

<p class=MsoNormal style='margin-left:.5in'>Equivalent of Haskell’s <span
class=SpellE>foldr</span> – better explained on the net.</p>

<p><br>
<!-- End of entry for FOLDR/ --><!-- Entry for FOLDR1/ -->[Function<span
class=GramE>]</span><br>
<a name="foldr1/"><b>foldr1/</b> <i>function list</i> =&gt; <i>result</i></a> </p>

<p class=MsoNormal style='margin-left:.5in'>Equivalent of Haskell’s foldr1 – <span
class=SpellE>foldr</span> with the first in the list used as <i
style='mso-bidi-font-style:normal'>first<o:p></o:p></i></p>

<p><br>
<!-- End of entry for FOLDR1/ --><!-- Entry for GROUPED-BY-FIRSTS-IN-CONS-PAIRS/ -->[Function<span
class=GramE>]</span><br>
<b>grouped-<span class=SpellE>cdrs</span>-by-car/</b> <i>list-of-cons-pairs </i><a
name="grouped-by-firsts-in-cons-pairs/"><tt><i><span style='font-size:10.0pt'>&amp;key</span></i></tt><i>
test</i> =&gt; </a><i>key-&gt;values-list pairs list, lookup function</i> </p>

<p class=MsoNormal style='margin-left:.5in'>Basically – a very useful
orthogonal way to interact functionally with a hash-table.</p>

<p class=MsoNormal style='margin-left:.5in'><br>
Takes a lazy-list or sequence of cons pairs, of the form (<span class=GramE>first
.</span> second) - returns a list of <span class=SpellE>conses</span> of the
form (first . (<span class=GramE>second</span> 0 second1 second2 second3....)) <span
class=GramE>as</span> the first value, where the seconds are matches on first.</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'>Second return value is a <span
class=GramE>function, that</span> returns a list of seconds based on a search
key/first as first value, found (T or NIL) as second.</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>In
Eager context: </i>grouped-<span class=SpellE>cdrs</span>-by-car/ calculates
the internal hash immediately.</p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>In
Lazy context:</i> <i style='mso-bidi-font-style:normal'><span
style='mso-spacerun:yes'> </span>T</i>he creation of the internal hash is
deferred – it is created either on traversal of the resultant list, or
execution of the second return value. </p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>Example:<o:p></o:p></i></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><b style='mso-bidi-font-weight:
normal'><span style='font-size:10.0pt'>REPL&gt;</span></b></tt><tt><span
style='font-size:10.0pt'> (grouped-<span class=SpellE>cdrs</span>-by-car/ '((<span
class=GramE><b style='mso-bidi-font-weight:normal'>1</b> .</span> 2) (<b
style='mso-bidi-font-weight:normal'>2</b> . <span style='color:red'>4</span>) (<b
style='mso-bidi-font-weight:normal'>2</b> . <span style='color:red'>5</span>) (<b
style='mso-bidi-font-weight:normal'>3</b> . 9) (<b style='mso-bidi-font-weight:
normal'>2</b> . <span style='color:red'>7</span>)))<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'>(LIST/
(<b style='mso-bidi-font-weight:normal'>1</b> 2) (<b style='mso-bidi-font-weight:
normal'>2</b> <span style='color:red'>4 5 7</span>) (<b style='mso-bidi-font-weight:
normal'>3</b> 9)); first result value = lazy-list of (cons <b style='mso-bidi-font-weight:
normal'>key</b> <span style='color:red'>values-list</span>)<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'>#&lt;Function&gt;<span
style='mso-spacerun:yes'>                  </span>; second result value is a
lookup function<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><b style='mso-bidi-font-weight:
normal'><span style='font-size:10.0pt'>REPL&gt;</span></b></tt><tt><span
style='font-size:10.0pt'> (<span class=SpellE>defparameter</span> <b
style='mso-bidi-font-weight:normal'>x<o:p></o:p></b></span></tt></p>

<p class=MsoNormal style='margin-left:1.5in;text-indent:.5in'><tt><span
style='font-size:10.0pt'>(<span class=GramE><b style='mso-bidi-font-weight:
normal'>multiple-value-list</b></span><b style='mso-bidi-font-weight:normal'><o:p></o:p></b></span></tt></p>

<p class=MsoNormal style='margin-left:2.0in;text-indent:.5in'><tt><span
style='font-size:10.0pt'>(grouped-<span class=SpellE>cdrs</span>-by-car/ '((<span
class=GramE><b style='mso-bidi-font-weight:normal'>1</b> .</span> 2) (<b
style='mso-bidi-font-weight:normal'>2</b> . <span style='color:red'>4</span>) (<b
style='mso-bidi-font-weight:normal'>2</b> . <span style='color:red'>5</span>) (<b
style='mso-bidi-font-weight:normal'>3</b> . 9) (<b style='mso-bidi-font-weight:
normal'>2</b> . <span style='color:red'>7</span>)))))<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'>X<span
style='mso-spacerun:yes'>   </span>; x now contains first and second
return-values consecutively in a CL proper list.<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><b style='mso-bidi-font-weight:
normal'><span style='font-size:10.0pt'>REPL&gt;</span></b></tt><tt><span
style='font-size:10.0pt'> (first <b style='mso-bidi-font-weight:normal'>x</b>)<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'>(LIST/
(<b style='mso-bidi-font-weight:normal'>1</b> 2) (<b style='mso-bidi-font-weight:
normal'>2</b> <span style='color:red'>4 5 7</span>) (<b style='mso-bidi-font-weight:
normal'>3</b> 9))<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><b style='mso-bidi-font-weight:
normal'><span style='font-size:10.0pt'>REPL&gt;</span></b></tt><tt><span
style='font-size:10.0pt'> (<span class=SpellE>funcall</span> (second <b
style='mso-bidi-font-weight:normal'>x</b>) <b style='mso-bidi-font-weight:normal'>2</b>)<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'>(<span
style='color:red'>4 5 7</span>)<span style='mso-spacerun:yes'>    </span>; list
or values supplied under key 2<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'>T<span
style='mso-spacerun:yes'>          </span>; Found<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><b style='mso-bidi-font-weight:
normal'><span style='font-size:10.0pt'>REPL&gt;</span></b></tt><tt><span
style='font-size:10.0pt'> (<span class=SpellE>funcall</span> (second <b
style='mso-bidi-font-weight:normal'>x</b>) <b style='mso-bidi-font-weight:normal'>1</b>)<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'>(2)<span
style='mso-spacerun:yes'>        </span>; Values under key 1<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'>T<span
style='mso-spacerun:yes'>          </span>; Found<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><b style='mso-bidi-font-weight:
normal'><span style='font-size:10.0pt'>REPL&gt;</span></b></tt><tt><span
style='font-size:10.0pt'> (<span class=SpellE>funcall</span> (second <b
style='mso-bidi-font-weight:normal'>x</b>) 7)<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'>NIL<span
style='mso-spacerun:yes'>        </span>; empty list (not found)<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'>NIL<span
style='mso-spacerun:yes'>        </span>; Not found<o:p></o:p></span></tt></p>

<p><br>
<!-- End of entry for GROUPED-BY-FIRSTS-IN-CONS-PAIRS/ --><!-- Entry for GROUPED-BY-FIRSTS-IN-LIST-PAIRS/ -->[Function<span
class=GramE>]</span><br>
<b>grouped-seconds-by-first/</b> <i>list-of-list-pairs </i><a
name="grouped-by-firsts-in-list-pairs/"><tt><i><span style='font-size:10.0pt'>&amp;key</span></i></tt><i>
test</i> =&gt; <i>result</i></a> </p>

<p class=MsoNormal style='margin-left:.5in'>Equivalent to grouped-<span
class=SpellE>cdrs</span>-by-car/, except that the input pairs come as a list of
lists, instead of a list of <span class=SpellE>conses</span>. </p>

<p><br>
<!-- End of entry for GROUPED-BY-FIRSTS-IN-LIST-PAIRS/ --><!-- Entry for HEAD-TAIL/ -->[Function<span
class=GramE>]</span><br>
<a name="head-tail/"><b>head-tail/</b> <i>list</i> =&gt; </a><i
style='mso-bidi-font-style:normal'>first element as first return-value, rest of
list as second return-value</i> </p>

<p class=MsoNormal style='margin-left:.5in'>Returns head and tail of a
lazy-list as return-values</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>Example:<o:p></o:p></i></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><b style='mso-bidi-font-weight:
normal'><span style='font-size:10.0pt'>REPL&gt;</span></b></tt><tt><span
style='font-size:10.0pt'> (head-tail '(1 2 3 4 5))<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'>1<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'>(<span
class=GramE>list</span>/ 2 3 4 5 6) ; result is a lazy-list regardless of
input; but will generally<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><span
style='mso-tab-count:3'>                  </span>; <span class=GramE>lazy-list</span>
implementation optimal to the input, e.g. list-based<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:2.0in;text-indent:.5in'><tt><span
style='font-size:10.0pt'>; <span class=GramE>for</span> proper list input.<o:p></o:p></span></tt></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p><br>
<!-- End of entry for HEAD-TAIL/ --><!-- Entry for HEAD/ -->[Function<span
class=GramE>]</span><br>
<a name="head/"><b>head/</b> <i>list</i> =&gt; <i>result</i></a> </p>

<p class=MsoNormal style='margin-left:.5in'>Returns head of a list – equivalent
of <i style='mso-bidi-font-style:normal'>car/</i></p>

<p><br>
<!-- End of entry for HEAD/ --><!-- Entry for INTERSPERSE/ -->[Function<span
class=GramE>]</span><br>
<b>intersperse/</b> <span class=SpellE><i>val</i></span><a name="intersperse/"><i>
list</i> =&gt; <i>result</i></a> </p>

<p class=MsoNormal style='margin-left:.5in'>Returns a lazy-list with <span
class=SpellE><span class=GramE><i style='mso-bidi-font-style:normal'>val</i></span></span>
interspersed between elements of <i style='mso-bidi-font-style:normal'>list</i>.</p>

<p><br>
<!-- End of entry for INTERSPERSE/ --><!-- Entry for ITERATE/ -->[Function<span
class=GramE>]</span><br>
<b>iterate/</b> <i>from-previous element </i><tt><i><span style='font-size:
10.0pt'>&amp;optional</span></i></tt><i> end-before-<span class=SpellE>func</span></i><a
name="iterate/"> =&gt; <i>result</i></a> </p>

<p class=MsoNormal style='margin-left:.5in'>Equivalent of Haskell’s <span
class=GramE><i style='mso-bidi-font-style:normal'>iterate</i></span> – returns
an infinite list of element, then function <i style='mso-bidi-font-style:normal'>from-previous</i>
successively applied to each list <span class=SpellE>elemenet</span>.</p>

<p><br>
<!-- End of entry for ITERATE/ --><!-- Entry for ITERATEX/ -->[Function<span
class=GramE>]</span><br>
<span class=SpellE><b>iteratex</b></span><a name="iteratex/"><b>/</b> <i>input-to-contribution
initial-input</i> =&gt; <i>result</i></a> </p>

<p style='margin-left:.5in'><span class=GramE>Rigged to default to iterate/
behavior, except input-to-contribution MUST return a list, even if that list is
a list of one value.</span> </p>

<p><br>
<!-- End of entry for LATCH-ON/ --><!-- Entry for LAZY -->[Macro<span
class=GramE>]</span><br>
<a name=lazy><b>lazy</b> <i>declaration* statement*</i> =&gt; <i>result</i></a>
</p>

<p class=MsoNormal style='margin-left:.5in'><br>
Enters an &quot;Eager&quot; context - calls to functions such as tail/ don’t do
<span class=SpellE>do</span> traversal before returning value; but at traversal
time of the result. This context uses a special variable, and extends into
sub-calls until overridden.<span style='mso-spacerun:yes'>  </span>Eager
context is the default.<span style='mso-spacerun:yes'>  </span>Relevant
functions are documented with their respective context effects.</p>

<p><br>
<br>
<!-- End of entry for LAZY --><!-- Entry for LAZY-LIST --><!-- End of entry for LAZY-LIST --><!-- Entry for LENGTH/ -->[Function<span
class=GramE>]</span><br>
<a name="length/"><b>length/</b> <i>list</i> =&gt; </a><i>integer length</i> </p>

<p class=MsoNormal style='margin-left:.5in'><span class=GramE>Traverses its
input list to the end, counting the elements.</span><span
style='mso-spacerun:yes'>  </span>Where possible, (input is an array or other
considerations) <i style='mso-bidi-font-style:normal'>length/</i> attempts to
avoid traversal.</p>

<p><br>
<!-- End of entry for LENGTH/ --><!-- Entry for LET/ -->[Function<span
class=GramE>]</span><br>
<b>list*/</b> <a name="list*/"><tt><i><span style='font-size:10.0pt'>&amp;rest</span></i></tt><i>
list-list-terminated</i> =&gt; <i>result</i></a> </p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>Identical
to <span class=SpellE>prepend</span>/<o:p></o:p></i></p>

<p class=MsoNormal style='margin-left:.5in'>Equivalent of CL’s <i
style='mso-bidi-font-style:normal'>list*</i> - returns a lazy-list of all input
parameters, except for the last which must be a list or lazy-list and has its
elements chained onto the end.</p>

<p><br>
<!-- End of entry for LIST*/ --><!-- Entry for LIST/ -->[Function<span
class=GramE>]</span><br>
<b>list/</b> <tt><i><span style='font-size:10.0pt'>&amp;rest</span></i></tt><i>
<span class=SpellE>rest</span></i><a name="list/"> =&gt; <i>result</i></a> </p>

<p class=MsoNormal style='margin-left:.5in'>Equivalent of CL’s <i
style='mso-bidi-font-style:normal'>list</i> function – returns a lazy-list
comprising all input parameters (in implementation, this list will be marked as
proper-list-based and will enjoy certain optimizations in functions using it).</p>

<p><br>
<!-- End of entry for LIST/ --><!-- Entry for LOOP-OVER/ -->[Macro<span
class=GramE>]</span><br>
<a name="loop-over/"><b>loop-over/</b> <i>symbol lazy-list declaration*
statement*</i> =&gt; </a><i>NIL</i></p>

<p class=MsoNormal style='margin-left:.5in'><span class=GramE>Runs <i
style='mso-bidi-font-style:normal'>*statement*</i> with <i style='mso-bidi-font-style:
normal'>symbol</i> taking on the value of each element in <i style='mso-bidi-font-style:
normal'>lazy-list</i>.</span><span style='mso-spacerun:yes'>  </span>Note:<span
style='mso-spacerun:yes'>  </span>Only accepts lazy-lists.</p>

<p><br>
<!-- End of entry for LOOP-OVER/ --><!-- Entry for MAP/ -->[Function<span
class=GramE>]</span><br>
<b>map/</b> <i>function first </i><a name="map/"><tt><i><span style='font-size:
10.0pt'>&amp;rest</span></i></tt><i> other-lazy-lists</i> =&gt; </a><i>lazy-list</i>
</p>

<p class=MsoNormal style='margin-left:.5in'>Quintessential map function – takes
multiple lists/lazy-lists, traverses and passes the current from each as parameters
to <i style='mso-bidi-font-style:normal'>function</i>.<span
style='mso-spacerun:yes'>  </span><span class=GramE>Stops on reaching the end
of any of its input lists</span> (i.e. the shortest).</p>

<p><br>
<!-- End of entry for MAP/ --><!-- Entry for MEMOIZED/ -->[Function<span
class=GramE>]</span><br>
<span class=SpellE><b>memoized</b></span><a name="memoized/"><b>/</b> <i>list</i>
=&gt; <i>result</i></a> </p>

<p class=MsoNormal style='margin-left:.5in'><span class=SpellE>Memoizes</span>
list nodes for traversal and (where underlying list dictates) value.<span
style='mso-spacerun:yes'>  </span>Any links traversed or values made available/extracted
will be stored in memory for future accesses.<span style='mso-spacerun:yes'>  
</span>Generally detects lists that are already <span class=SpellE>memoized</span>,
or <span class=GramE>that are</span> based on a static structure (e.g. proper
list) and returns its input list.</p>

<p><o:p>&nbsp;</o:p></p>

<p>[Function<span class=GramE>]</span><br>
<b>non-null/</b> <i>list</i> =&gt; <i>Boolean, NIL or something else</i></p>

<p class=MsoNormal style='margin-left:.5in'>NIL if list contains contents,
non-NIL if empty</p>

<p><br>
<!-- End of entry for MEMOIZED/ --><!-- Entry for NTH/ -->[Function<span
class=GramE>]</span><br>
<a name="nth/"><b>nth/</b> <i>index list</i> =&gt; </a><i>value</i></p>

<p class=MsoNormal style='margin-left:.5in'>Traverses <i style='mso-bidi-font-style:
normal'>index</i> elements through list and returns the evaluated value at that
location.</p>

<p><br>
<!-- End of entry for NTH/ --><!-- Entry for NTHCDR/ -->[Function<span
class=GramE>]</span><br>
<span class=SpellE><b>nthcdr</b></span><a name="nthcdr/"><b>/</b> <i>to-drop
list</i> =&gt; </a><i>result lazy-list</i></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>Identical
to drop/<o:p></o:p></i></p>

<p class=MsoNormal style='margin-left:.5in'>Returns lazy-list with first <i
style='mso-bidi-font-style:normal'>to-drop</i> elements skipped/traversed from
list, or empty list if end reached<span class=GramE>..</span></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>In
Eager context: </i>Traverses list immediately, returning sub-list after <i
style='mso-bidi-font-style:normal'>drop-list</i> traversals<span class=GramE>..</span></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>In
Lazy context:</i> Does not traverse <i style='mso-bidi-font-style:normal'>list</i>
– first traversal of result will trigger test to find first non-NIL.<span
style='mso-spacerun:yes'>  </span>(Storage warning:<span
style='mso-spacerun:yes'>  </span>result will internally keep references to
original list + to-drop).</p>

<p><br>
<!-- End of entry for NTHCDR/ --><!-- Entry for NUB-BY/ -->[Function<span
class=GramE>]</span><br>
<a name="nub-by/"><b>nub-by/</b> <i>equality list</i> =&gt; </a><i>lazy-list of
<span class=SpellE>uniques</span></i></p>

<p class=MsoNormal style='margin-left:.5in'>Equality has to be one of the valid
inputs <span class=GramE>to :test</span> field in CL make-hash-table (‘<span
class=SpellE>eq</span>, ‘<span class=SpellE>eql</span>, ‘equal, ‘<span
class=SpellE>equalp</span>)</p>

<p class=MsoNormal style='margin-left:.5in'><span class=GramE>Returns a <span
class=SpellE>memoized</span> list with uniqueness guaranteed by hash-table
test.</span><span style='mso-spacerun:yes'>  </span><i style='mso-bidi-font-style:
normal'>List</i> is scanned on an as-needed basis to satisfy initial requests
to result.</p>

<p><br>
<!-- End of entry for NUB-BY/ --><!-- Entry for NUB/ -->[Function<span
class=GramE>]</span><br>
<a name="nub/"><b>nub/</b> <i>list</i> =&gt; <i>result</i></a> </p>

<p class=MsoNormal style='margin-left:.5in'>Basically nub-by/ with its first
parameter as ‘<span class=SpellE>eql</span></p>

<p><br>
<!-- End of entry for NUB/ --><!-- Entry for NULL/ -->[Function<span
class=GramE>]</span><br>
<a name="null/"><b>null/</b> <i>list</i> =&gt; </a><i>Boolean, NIL or something
else</i></p>

<p class=MsoNormal style='margin-left:.5in'>Returns non-NIL if lazy-list is
non-empty.<span style='mso-spacerun:yes'>  </span>For lazy-lists that aren’t
based on a fixed container, this may cause traversal through a single element
to determine end.</p>

<p><br>
<!-- End of entry for NULL/ --><!-- Entry for OR/ -->[Function<span
class=GramE>]</span><br>
<a name="or/"><b>or/</b> <i>list</i> =&gt; </a><i>NIL or first non-NIL</i>
element in list</p>

<p class=MsoNormal style='margin-left:.5in'><span class=GramE>Returns first
non-NIL in list.</span><span style='mso-spacerun:yes'>  </span>For lazy-lists,
traverses only to the first non-NIL element.<span style='mso-spacerun:yes'> 
</span>Where relevant, causes evaluation (to value) of traversed elements.</p>

<p><br>
<!-- End of entry for OR/ --><!-- Entry for POSITION/ -->[Function<span
class=GramE>]</span><br>
<b>position/</b> <i>item list </i><a name="position/"><tt><i><span
style='font-size:10.0pt'>&amp;key</span></i></tt><i> test</i> =&gt; <i>result</i></a>
</p>

<p class=MsoNormal style='margin-left:1.0in;text-indent:-.5in'>Analogous to
CL’s position function – traverses <i style='mso-bidi-font-style:normal'>list</i>,
comparing value found with <i style='mso-bidi-font-style:normal'>item</i> using
<i style='mso-bidi-font-style:normal'>test</i> (which defaults to ‘<span
class=SpellE>eql</span>).</p>

<p><br>
<!-- End of entry for POSITION/ --><!-- Entry for PREPEND/ -->[Function<span
class=GramE>]</span><br>
<span class=SpellE><b>prepend</b></span><b>/</b> <a name="prepend/"><tt><i><span
style='font-size:10.0pt'>&amp;rest</span></i></tt><i> list-list-terminated</i>
=&gt; <i>result</i></a> </p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>Identical
to list*/<o:p></o:p></i></p>

<p class=MsoNormal style='margin-left:.5in'>Equivalent of CL’s <i
style='mso-bidi-font-style:normal'>list*</i> - returns a lazy-list of all input
parameters, except for the last which must be a list or lazy-list and has its
elements chained onto the end.</p>

<p><br>
<!-- End of entry for PREPEND/ --><!-- Entry for RCURRIED -->[Function<span
class=GramE>]</span><br>
<a name=rcurried></a><span class=SpellE><span style='mso-bookmark:rcurried'><b>rcurried</b></span></span><span
style='mso-bookmark:rcurried'> <i>function </i></span><span style='mso-bookmark:
rcurried'><tt><i><span style='font-size:10.0pt'>&amp;rest</span></i></tt><i> <span
class=SpellE>rargs</span></i> =&gt; </span><i>function</i> </p>

<p class=MsoNormal style='margin-left:.5in'>Returns a function that applies its
parameters + <span class=SpellE><i style='mso-bidi-font-style:normal'>rargs</i></span>
to <i style='mso-bidi-font-style:normal'>function</i></p>

<p><br>
<!-- End of entry for RCURRIED --><!-- Entry for SECOND/ -->[Function<span
class=GramE>]</span><br>
<span class=SpellE><b>scanl</b></span><b>/</b> <i>function first list</i> =&gt;
<i>list of intermediate results</i></p>

<p class=MsoNormal style='margin-left:.5in'>Equivalent of Haskell’s <span
class=SpellE><i style='mso-bidi-font-style:normal'>scanl</i></span> – better
explained on the net.</p>

<p><br>
<!-- End of entry for FOLDL/ --><!-- Entry for FOLDL1/ -->[Function<span
class=GramE>]</span><br>
<b>scanl1/</b> <i>function list</i> =&gt; <i>list of intermediate results</i></p>

<p class=MsoNormal style='margin-left:.5in'>Equivalent of Haskell’s <i
style='mso-bidi-font-style:normal'>scanl1</i> – better explained on the net.</p>

<p><br>
<!-- End of entry for FOLDL1/ --><!-- Entry for FOLDR/ -->[Function<span
class=GramE>]</span><br>
<span class=SpellE><b>scanr</b></span><b>/</b> <i>function first list</i> =&gt;
<i>list of intermediate results</i></p>

<p class=MsoNormal style='margin-left:.5in'>Equivalent of Haskell’s <span
class=SpellE><i style='mso-bidi-font-style:normal'>scanr</i></span> – better
explained on the net.</p>

<p><br>
<!-- End of entry for FOLDR/ --><!-- Entry for FOLDR1/ -->[Function<span
class=GramE>]</span><br>
<b>scanr1/</b> <i>function list</i> =&gt; <i>list of intermediate results</i></p>

<p class=MsoNormal style='margin-left:.5in'>Equivalent of Haskell’s scanr1 – better
explained on the net.<i style='mso-bidi-font-style:normal'><o:p></o:p></i></p>

<p><br>
<!-- End of entry for FOLDR1/ --><!-- Entry for GROUPED-BY-FIRSTS-IN-CONS-PAIRS/ --><span
style='mso-spacerun:yes'> </span>[Function<span class=GramE>]</span><br>
<a name="second/"><b>second/</b> <i>list</i> =&gt; <i>result</i></a> </p>

<p class=MsoNormal><span style='mso-tab-count:1'>            </span>Analogous
to CL’s <i style='mso-bidi-font-style:normal'>second</i>, returns the second
element in supplied sequence/lazy-list, nil if list is smaller than length 2.</p>

<p><br>
<!-- End of entry for SECOND/ --><!-- Entry for SELF-REF-LIST/ -->[Macro<span
class=GramE>]</span><br>
<a name="self-ref-list/"><b>self-ref-list/</b> <i>ref-name declaration*
statement*</i> =&gt; </a><i>lazy-list</i></p>

<p class=MsoNormal style='margin-left:.5in'>Defines a lexical context in which <i
style='mso-bidi-font-style:normal'>ref-name</i> is assigned the list defined by
<i style='mso-bidi-font-style:normal'>statement</i>, which may refer to itself
via <i style='mso-bidi-font-style:normal'>ref-name</i>.</p>

<p class=MsoNormal style='margin-left:.5in'>The forms in <i style='mso-bidi-font-style:
normal'>statement</i> are executed in a lazy evaluation context.<span
style='mso-spacerun:yes'>  </span>This is due to a convention amongst lazy-list
functions that traverse lists, that they don’t actually attempt traversal until
the first request against them.<span style='mso-spacerun:yes'>  </span>While
the lazy context can be overridden/the list otherwise traversed, any attempt to
do so before the full <i style='mso-bidi-font-style:normal'>statement</i> form
is evaluated will fail.</p>

<p class=MsoNormal style='margin-left:.5in'>The evaluated list is <span
class=SpellE><span class=GramE>memoized</span></span><span class=GramE>/cached</span>.</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'>The forms in <i style='mso-bidi-font-style:
normal'>statement</i> are executed to create the underlying <span class=SpellE>memoized</span>
list <i style='mso-bidi-font-style:normal'>only on first traversal</i>.<span
style='mso-spacerun:yes'>  </span>This is a performance optimization to
accommodate most CL implementations, where callers of a function keep that
reference ineligible for garbage collection.</p>

<p class=MsoNormal style='margin-left:.5in'>Consider the clichéd Fibonacci
example:</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'>(<span class=GramE>nth</span>/
1000000</p>

<p class=MsoNormal style='margin-left:1.0in'><span
style='mso-spacerun:yes'> </span>(<b style='mso-bidi-font-weight:normal'><span
style='color:green'>self-ref-list/</span></b> <b style='mso-bidi-font-weight:
normal'><span style='color:blue'>fib</span></b> (list*/ 1 <span class=SpellE>1</span>
(map/ #'+ <b style='mso-bidi-font-weight:normal'><span style='color:blue'>fib</span></b>
(tail/ <b style='mso-bidi-font-weight:normal'><span style='color:blue'>fib</span></b>)))))</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'>This example requires the
memorization to keep this from becoming the recursive solution (performance wise).<span
style='mso-spacerun:yes'>  </span>However, if the caller to <i
style='mso-bidi-font-style:normal'>nth/</i> were to keep the pointer to the
head, every calculated result would be kept ineligible for garbage
collection.<span style='mso-spacerun:yes'>  </span>Thus, the forms inside the
self-ref-list are only evaluated upon the first access by <i style='mso-bidi-font-style:
normal'>nth/</i>’s implementation starting traversal, and the head of the <span
class=SpellE>memoized</span> chain is not kept by the caller, only the ability
to request the list be recreated from scratch.</p>

<p class=MsoNormal style='margin-left:.5in'>In this Fibonacci example, due to
the implementation’s details, as <i style='mso-bidi-font-style:normal'>nth/ </i>traverses;
only the “previous” and “current” numerical values are kept ineligible for
garbage collection.</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'>In short, it works the way it does
to allow control over or minimization of the memory footprint in calculating
solutions based upon self-referencing lists.</p>

<p><br>
<!-- End of entry for SELF-REF-LIST/ --><!-- Entry for SORT-BY/ -->[Function<span
class=GramE>]</span><br>
<a name="sort-by/"><b>sort-by/</b> <i>ordering list</i> =&gt; </a><i>list</i></p>

<p class=MsoNormal style='margin-left:.5in'>Sorts <i style='mso-bidi-font-style:
normal'>list</i> via dual-input function <i style='mso-bidi-font-style:normal'>ordering</i>
(returning if first <span class=SpellE>param</span> should be before second).</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>In
Eager context: </i>Performs actual sort and creation of stored list of sorted
values at point of call, returning a CL proper-list based lazy-list.</p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>In
Lazy context:</i> Defers creation of persistent sorted list until first element
is traversed.<span style='mso-spacerun:yes'>  </span>Future advances through
list traverse a persistent proper list.<span style='mso-spacerun:yes'> 
</span>(Performance note:<span style='mso-spacerun:yes'>  </span>Re-traversing
the result list from the start causes a rerun of the sort algorithm/creation of
a new persistent sorted result.<span style='mso-spacerun:yes'>  </span>This is
of concern if double-scanning the result list).</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p><br>
<!-- End of entry for SORT-BY/ --><!-- Entry for SORT/ -->[Function<span
class=GramE>]</span><br>
<a name="sort/"><b>sort/</b> <i>list</i> =&gt; <i>result</i></a> </p>

<p class=MsoNormal style='margin-left:.5in'>Basically <i style='mso-bidi-font-style:
normal'>sort-by/</i> with <i style='mso-bidi-font-style:normal'>ordering</i>
parameter set to #'&lt;</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p>[Function<span class=GramE>]</span><br>
<b>split-at/</b> <i>index list</i> =&gt; <i>list from before index, list after</i></p>

<p class=MsoNormal style='margin-left:.5in'>First result is pre-index, second
result is list for at predicate true and later.<span style='mso-spacerun:yes'> 
</span>First result stores a persistent linked-list of values, except in lazy
mode when this linked list is created only on first traversal.</p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>In
Eager context: </i>First return value is linked-list based lazy-list, second
reads from input <i style='mso-bidi-font-style:normal'>list</i> from index
onward.</p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>In
Lazy context:</i><span style='mso-spacerun:yes'>  </span>First traversal of
either result will cause the traversal through <i style='mso-bidi-font-style:
normal'>list</i> to determine the actual split lists.<span
style='mso-spacerun:yes'>  </span>From then on, the result lists will
approximate their <i style='mso-bidi-font-style:normal'>Eager</i> counterparts,
albeit not being typed for any optimizations based on their contents.</p>

<p><o:p>&nbsp;</o:p></p>

<p><span style='mso-spacerun:yes'> </span>[Function<span class=GramE>]</span><br>
<b>split-when/</b> <i>predicate list</i> =&gt; <i>list from before predicate
true, list after</i></p>

<p class=MsoNormal style='margin-left:.5in'>First result is pre-predicate-true,
second result is list for at predicate true and later.<span
style='mso-spacerun:yes'>  </span>First result stores a persistent linked-list
of values, except in lazy mode when this linked list is created only on first
traversal.</p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>In
Eager context: </i>First return value is linked-list based lazy-list, second
reads from input <i style='mso-bidi-font-style:normal'>list</i> from
predicate-true point onward.</p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>In
Lazy context:</i><span style='mso-spacerun:yes'>  </span>First traversal of
either result will cause the traversal through <i style='mso-bidi-font-style:
normal'>list</i> to determine the actual split lists.<span
style='mso-spacerun:yes'>  </span>From then on, the result lists will
approximate their <i style='mso-bidi-font-style:normal'>Eager</i> counterparts,
albeit not being typed for any optimizations based on their contents.</p>

<p><br>
<!-- End of entry for SORT/ --><!-- Entry for SPLIT-DOWN-ON-TEST/ -->[Function<span
class=GramE>]</span><br>
<b>split-down-on-test/</b> <i>test list </i><a name="split-down-on-test/"><tt><i><span
style='font-size:10.0pt'>&amp;key</span></i></tt><i>
keep-split-causing-elements keep-empty-non-split process-split-causing-element
process-non-split-causing-elements-list</i> =&gt; </a><i>List of split lists,
possibly including the split-causing elements</i></p>

<p class=MsoNormal style='margin-left:.5in'>With default parameters, <i
style='mso-bidi-font-style:normal'>split-down-on-test/</i> returns a lazy-list
of lazy-lists containing contiguous elements of <i style='mso-bidi-font-style:
normal'>list</i> for which <i style='mso-bidi-font-style:normal'>test</i>
returns nil.</p>

<p class=MsoNormal style='margin-left:.5in'>The parameter <i style='mso-bidi-font-style:
normal'>keep-split-causing-elements</i> defaults to NIL; but with a non-NIL
value causes the items for which <i style='mso-bidi-font-style:normal'>test</i>
return non-NIL to be included in the result list – albeit on their own, not in
group lists.</p>

<p class=MsoNormal style='margin-left:.5in'>The parameter <i style='mso-bidi-font-style:
normal'>keep-empty-non-split</i> defaults to T –NIL empty lists (between
adjacent separators, or when separators at start or end) are culled.</p>

<p class=MsoNormal style='margin-left:.5in'>The parameter <i style='mso-bidi-font-style:
normal'>process-split-causing-element</i> accepts a function that can be used
to transform the elements retained by <i style='mso-bidi-font-style:normal'>keep-split-causing-elements</i></p>

<p class=MsoNormal style='margin-left:.5in'>The parameter <i style='mso-bidi-font-style:
normal'>process-non-split-causing-elements-list</i> allows transformation of
the contiguous non-splitting element lists.</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>Example:<o:p></o:p></i></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><b style='mso-bidi-font-weight:
normal'><span style='font-size:10.0pt'>REPL&gt;</span></b></tt><tt><span
style='font-size:10.0pt'> (split-down-on-test/ #'<span class=SpellE>evenp</span>
(list 1 3 2 5 <span class=SpellE>5</span> 7 8 7 9))<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'>(LIST<span class=GramE>/<span
style='mso-spacerun:yes'>  </span>(</span>LIST 1 3) (LIST/ 5 <span
class=SpellE>5</span> 7) (LIST/ 7 9))</p>

<p class=MsoNormal style='margin-left:1.0in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><b style='mso-bidi-font-weight:
normal'><span style='font-size:10.0pt'>REPL&gt;</span></b></tt><tt><span
style='font-size:10.0pt'> (split-down-on-test/ #'<span class=SpellE>evenp</span>
(list 1 3 2 5 <span class=SpellE>5</span> 7 8 7 9<span class=GramE>) <b
style='mso-bidi-font-weight:normal'>:keep</b></span><b style='mso-bidi-font-weight:
normal'>-split-causing-elements</b> t)<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'>(LIST/
(LIST/ 1 3) <b style='mso-bidi-font-weight:normal'>2</b> (LIST/ 5 <span
class=SpellE>5</span> 7) <b style='mso-bidi-font-weight:normal'>8</b> (LIST/ 7
9))<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><b style='mso-bidi-font-weight:
normal'><span style='font-size:10.0pt'>REPL&gt;</span></b></tt><tt><span
style='font-size:10.0pt'> (split-down-on-test/ #'<span class=SpellE>evenp</span>
(list 1 3 2 5 <span class=SpellE>5</span> 7 8 7 9<span class=GramE>) :keep</span>-split-causing-elements
t <b style='mso-bidi-font-weight:normal'>:process-split-causing-element (lambda
(x) (* x 1000))</b>)<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'>(LIST/
(LIST/ 1 3) <b style='mso-bidi-font-weight:normal'>2000</b> (LIST/ 5 <span
class=SpellE>5</span> 7) <b style='mso-bidi-font-weight:normal'>8000</b> (LIST/
7 9))<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><b style='mso-bidi-font-weight:
normal'><span style='font-size:10.0pt'>REPL&gt;</span></b></tt><tt><span
style='font-size:10.0pt'> (split-down-on-test/ #'<span class=SpellE>evenp</span>
(list 1 3 2 5 <span class=SpellE>5</span> 7 8 7 9<span class=GramE>) :keep</span>-split-causing-elements
t <b style='mso-bidi-font-weight:normal'>:process-non-split-causing-elements-list
(curried #'map/ (curried #'* 10))</b>)<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'>(LIST/
(LIST/ <b style='mso-bidi-font-weight:normal'>10 30</b>) 2 (LIST/ <b
style='mso-bidi-font-weight:normal'>50 <span class=SpellE>50</span> 70</b>) 8
(LIST/ <b style='mso-bidi-font-weight:normal'>70 90</b>))<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></tt></p>

<p class=MsoNormal style='margin-left:.5in'>Performance:<span
style='mso-spacerun:yes'>  </span>See <i style='mso-bidi-font-style:normal'>split-on-test</i>
from which <i style='mso-bidi-font-style:normal'>split-down-on-test</i>’s
actions are composed.<span style='mso-spacerun:yes'>  </span>By necessity,
traversal through the result items necessitates the scan/creation of the
prior.<span style='mso-spacerun:yes'>  </span>Each non-split list returned is <span
class=GramE>cached/<span class=SpellE>memoized</span></span>.</p>

<p><br>
<!-- End of entry for SPLIT-DOWN-ON-TEST/ --><!-- Entry for SPLIT-ON-TEST/ -->[Function<span
class=GramE>]</span><br>
<a name="split-on-test/"><b>split-on-test/</b> <i>test list</i> =&gt; </a><i>List
representing values before test true, list representing after test true, call
returning value at test true</i></p>

<p class=MsoNormal style='margin-left:.5in'>Returns 2 lists (before and after
test-true), and a function (as third return) that returns the value at
test-true, and a T/Nil if test-true were actually found (emptiness of the 2
lists is not evidence one way or another).</p>

<p class=MsoNormal style='margin-left:.5in'><span class=GramE>The
first/”before” list is cached/<span class=SpellE>memoized</span> on scan.</span></p>

<p class=MsoNormal style='margin-left:.5in'>The second/”after” return list
(after test) is not <span class=SpellE>memoized</span>; but causes the full
evaluation of the “before” upon traversal.</p>

<p class=MsoNormal style='margin-left:.5in'>The third value, the
call-for-value-at-test, causes the evaluation of the “before” list upon
traversal.</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'>Performance: Basically, <i
style='mso-bidi-font-style:normal'>split-on-test</i> is lazy in terms of
traversal of list or application of test; but, by necessity, the 2<sup>nd</sup>
and 3<sup>rd</sup> return values require that this traversal have taken place.</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p><br>
<!-- End of entry for SPLIT-ON-TEST/ --><!-- Entry for STRING-FROM-CHARS/ -->[Function<span
class=GramE>]</span><br>
<b>split-positional/</b> <i>positional list</i> =&gt; <i>Lazy-list of split
results</i></p>

<p class=MsoNormal style='margin-left:.5in'>Splits input <i style='mso-bidi-font-style:
normal'>list</i> to list of sub-lists based upon the position or positions
described in <i style='mso-bidi-font-style:normal'>positional</i>.</p>

<p class=MsoNormal style='margin-left:.5in'>Parameter<i style='mso-bidi-font-style:
normal'> positional</i> can be one of:</p>

<p class=MsoNormal style='margin-left:1.0in'>Integer:<span
style='mso-spacerun:yes'>  </span>Returns a list of lists with the first
terminating prior to integer in <i style='mso-bidi-font-style:normal'>positional</i>,
the remainder, (if any), will be in a second list.</p>

<p class=MsoNormal style='margin-left:1.0in'>Function:<span
style='mso-spacerun:yes'>  </span>A function that accepts an integer and
returns a T or NIL, with T indicating a split point.</p>

<p class=MsoNormal style='margin-left:1.0in'>List/lazy-list of integers, in
order – indicates a sequence of split points.</p>

<p class=MsoNormal style='margin-left:.5in'>The result list of <i
style='mso-bidi-font-style:normal'>split-positional</i> is always comprised of
the contents of <i style='mso-bidi-font-style:normal'>list</i>, with the <i
style='mso-bidi-font-style:normal'>positional</i> driving only the sub-lists
breakdown.<span style='mso-spacerun:yes'>  </span>Each split-point indicates
the start of a sub-list, with the exception of the first if it is not indicated
by <i style='mso-bidi-font-style:normal'>positional</i>.</p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>Example:<o:p></o:p></i></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><b style='mso-bidi-font-weight:
normal'><span style='font-size:10.0pt'>REPL&gt;</span></b></tt><tt><span
style='font-size:10.0pt'> (split-positional/ <b style='mso-bidi-font-weight:
normal'>'(5 7 8) </b>'(0 10 20 30 40 50 60 70 80 90 100 110 120))<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'>(LIST/ (LIST/ 0 10 20 30 40) (LIST/
50 60) (LIST/ 70) (LIST/ 80 90 100 110 120)<span class=GramE>)<span
style='mso-spacerun:yes'>  </span>;</span> Indices dictated by <i
style='mso-bidi-font-style:normal'>positional<o:p></o:p></i></p>

<p class=MsoNormal style='margin-left:1.0in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><b style='mso-bidi-font-weight:
normal'><span style='font-size:10.0pt'>REPL&gt;</span></b></tt><tt><span
style='font-size:10.0pt'> (split-positional/ (<b style='mso-bidi-font-weight:
normal'>composed #'<span class=SpellE>zerop</span> (<span class=SpellE>rcurried</span>
#'mod 3))</b> '(0 10 20 30 40 50 60 70 80 90 100 110 120))<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'>(LIST/ (LIST/ 0 10 20) (LIST/ 30
40 50) (LIST/ 60 70 80) (LIST/ 90 100 110) (LIST/ 120)<span class=GramE>)<span
style='mso-spacerun:yes'>  </span>;</span> indices validated against <b
style='mso-bidi-font-weight:normal'>mod-3</b> function provided to <i
style='mso-bidi-font-style:normal'>positional<o:p></o:p></i></p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p><br>
<!-- End of entry for SPLIT-ON-TEST/ --><!-- Entry for STRING-FROM-CHARS/ --><span
style='mso-spacerun:yes'> </span>[Function<span class=GramE>]</span><br>
<a name="tail/"><b>tail/</b> <i>list</i> =&gt; </a><i>result list</i></p>

<p class=MsoNormal style='margin-left:.5in'>Basically equivalent of <span
class=SpellE><i style='mso-bidi-font-style:normal'>cdr</i></span><i
style='mso-bidi-font-style:normal'>/</i>or (<i style='mso-bidi-font-style:normal'>drop
1 list)</i> – returns the sub-list after traversing in by one.</p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>In
Eager Context:</i> Traverses immediately, returns a list referencing only the
remainder.</p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>In
Lazy Context:</i> Defers traversal until first traversal of result list.<span
style='mso-spacerun:yes'>  </span><span class=GramE>Holds a reference to <i
style='mso-bidi-font-style:normal'>list</i> plus traversal logic.</span><span
style='mso-spacerun:yes'>  </span>Performance Warning:<span
style='mso-spacerun:yes'>  </span><i style='mso-bidi-font-style:normal'>tail/</i>
in a lazy context will keep a reference to all storage retained by <i
style='mso-bidi-font-style:normal'>list</i>.</p>

<p><br>
<!-- End of entry for TAIL/ --><!-- Entry for TAILS/ -->[Function<span
class=GramE>]</span><br>
<a name="tails/"><b>tails/</b> <i>list</i> =&gt; </a><i>Lazy-list of lists</i></p>

<p class=MsoNormal style='margin-left:.5in'>Returns a list of lists, where each
sub-list represents a successive <span class=SpellE><span class=GramE><i
style='mso-bidi-font-style:normal'>cdr</i></span></span> of the preceding one,
up to and including an empty list for the last.<span style='mso-spacerun:yes'> 
</span><span class=GramE>Doesn’t really cost more than traversal.</span></p>

<p class=MsoNormal style='margin-left:.5in'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in'><i style='mso-bidi-font-style:normal'>Example:<o:p></o:p></i></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><b style='mso-bidi-font-weight:
normal'><span style='font-size:10.0pt'>REPL&gt;</span></b></tt><tt><span
style='font-size:10.0pt'> (tails/ '(1 2 3 4 5))<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'>(LIST/<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><span
style='mso-spacerun:yes'> </span>(LIST/ 1 2 3 4 5)<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><span
style='mso-spacerun:yes'> </span>(LIST/ 2 3 4 5)<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><span
style='mso-spacerun:yes'> </span>(LIST/ 3 4 5)<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><span
style='mso-spacerun:yes'> </span>(LIST/ 4 5)<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><span
style='mso-spacerun:yes'> </span>(LIST/ 5)<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:1.0in'><tt><span style='font-size:10.0pt'><span
style='mso-spacerun:yes'> </span>(LIST/))</span></tt></p>

<p><br>
<!-- End of entry for TAILS/ --><!-- Entry for TAKE-WHILE/ -->[Function<span
class=GramE>]</span><br>
<a name="take-while/"><b>take-while/</b> <i>test list</i> =&gt; </a><i>List</i>
</p>

<p class=MsoNormal style='margin-left:.5in'>Returns a list composed of elements
of <i style='mso-bidi-font-style:normal'>list</i> up until (but not including)
the first element for which <i style='mso-bidi-font-style:normal'>test</i>
returns non-NIL.</p>

<p class=MsoNormal style='margin-left:.5in'>Performance note:<span
style='mso-spacerun:yes'>  </span>Result list maintains a reference to <i
style='mso-bidi-font-style:normal'>list</i> (keeping it ineligible for garbage
collection).<span style='mso-spacerun:yes'>  </span><span class=GramE>Convert
result to a fixed container (one traversal + new storage) if this is
undesirable.</span></p>

<p><br>
<!-- End of entry for TAKE-WHILE/ --><!-- Entry for TAKE/ -->[Function<span
class=GramE>]</span><br>
<a name="take/"><b>take/</b> <i>to-take list</i> =&gt; </a><i>List</i></p>

<p class=MsoNormal style='margin-left:.5in'><span class=GramE>Returns a list of
the first <i style='mso-bidi-font-style:normal'>to-take</i> elements in <i
style='mso-bidi-font-style:normal'>list</i> if available.</span></p>

<p class=MsoNormal style='margin-left:.5in'>Performance note:<span
style='mso-spacerun:yes'>  </span>Result list maintains a reference to <i
style='mso-bidi-font-style:normal'>list </i>(keeping it ineligible for garbage
collection).<span style='mso-spacerun:yes'>  </span><span class=GramE>Convert
result to a fixed container (one traversal + new storage) if this is
undesirable.</span></p>

<p><br>
<!-- End of entry for TAKE/ --><!-- Entry for THIRD/ -->[Function<span
class=GramE>]</span><br>
<a name="third/"><b>third/</b> <i>list</i> =&gt; <i>result</i></a> </p>

<p class=MsoNormal style='margin-left:.5in'>Equivalent of CL’s <i
style='mso-bidi-font-style:normal'>third</i> – returns the third element in an
input list/lazy-list/sequence if available.</p>

<p><br style='mso-special-character:line-break'>
<![if !supportLineBreakNewLine]><br style='mso-special-character:line-break'>
<![endif]><o:p></o:p></p>

</div>

<!-- End of entry for TO-LIST --><!-- Entry for TO-STRING -->
</body>

</html>
